import json
import os

notebook_cells = [
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "# Forward Model Stress-Test & Range Discovery\n",
            "\n",
            "## How to use this notebook\n",
            "1. **Run All Cells**: Start by running all cells to initialize the environment and load the model.\n",
            "2. **Interactive Visualization**: Use the widget panel to manually explore how parameters affect the phase map.\n",
            "3. **Range Discovery (Sweeps)**: Run the sweep sections to generate plots of stability metrics vs parameters.\n",
            "4. **Diagnostics**: Use the gradient checks to find where the model becomes unstable or insensitive.\n",
            "5. **Recommendations**: Read the final section for permissible parameter ranges.\n",
            "\n",
            "**Note**: This notebook uses `src.inversion.forward_model`. Ensure you are running it from the project root."
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# 1. Imports and Environment Check\n",
            "import sys\n",
            "import os\n",
            "import numpy as np\n",
            "import torch\n",
            "import matplotlib.pyplot as plt\n",
            "import ipywidgets as widgets\n",
            "from IPython.display import display, clear_output\n",
            "\n",
            "# Ensure project root is in path\n",
            "if os.getcwd() not in sys.path:\n",
            "    sys.path.append(os.getcwd())\n",
            "\n",
            "print(f\"Python Version: {sys.version.split()[0]}\")\n",
            "print(f\"PyTorch Version: {torch.__version__}\")\n",
            "print(f\"Device: {'cuda' if torch.cuda.is_available() else 'cpu'}\")\n",
            "\n",
            "try:\n",
            "    from src.inversion import forward_model\n",
            "    print(\"\\nSUCCESS: Imported src.inversion.forward_model\")\n",
            "    print(f\"Source file: {forward_model.__file__}\")\n",
            "except ImportError as e:\n",
            "    print(f\"\\nERROR: Could not import forward_model. Make sure you are in the project root.\\n{e}\")"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# 2. Forward Model API Discovery\n",
            "import inspect\n",
            "\n",
            "print(\"--- Forward Model Introspection ---\")\n",
            "functions = inspect.getmembers(forward_model, inspect.isfunction)\n",
            "for name, func in functions:\n",
            "    if func.__module__ == forward_model.__name__:\n",
            "        print(f\"Function: {name}\")\n",
            "        print(f\"  Signature: {inspect.signature(func)}\")\n",
            "        doc = inspect.getdoc(func)\n",
            "        if doc:\n",
            "            print(f\"  Docstring: {doc.splitlines()[0]}...\")\n",
            "        print(\"-\" * 30)"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# 3. Differentiable Wrapper & Helper Functions\n",
            "\n",
            "def differentiable_forward(xc, yc, S, focal_length, wavelength, N=128):\n",
            "    \"\"\"\n",
            "    A fully differentiable wrapper around the forward model logic.\n",
            "    Generates the grid and computes phase.\n",
            "    \"\"\"\n",
            "    # Create grid in a differentiable way\n",
            "    # linspace is essentially: start + (end-start) * steps\n",
            "    device = xc.device if isinstance(xc, torch.Tensor) else 'cpu'\n",
            "    \n",
            "    steps = torch.linspace(0, 1, N, device=device)\n",
            "    \n",
            "    x_start = xc - S / 2.0\n",
            "    x_end = xc + S / 2.0\n",
            "    # Expand dims for broadcasting: (N, 1)\n",
            "    x_coords = x_start + (x_end - x_start) * steps\n",
            "    \n",
            "    y_start = yc - S / 2.0\n",
            "    y_end = yc + S / 2.0\n",
            "    # Expand dims for broadcasting: (1, N)\n",
            "    y_coords = y_start + (y_end - y_start) * steps\n",
            "    \n",
            "    # Create meshgrid manually to preserve gradients if needed\n",
            "    # X_grid: (N, N), varies along columns (dim 1)\n",
            "    X_grid = x_coords.unsqueeze(0).expand(N, N)\n",
            "    # Y_grid: (N, N), varies along rows (dim 0)\n",
            "    Y_grid = y_coords.unsqueeze(1).expand(N, N)\n",
            "    \n",
            "    phase = forward_model.compute_hyperbolic_phase(X_grid, Y_grid, focal_length, wavelength)\n",
            "    return phase\n",
            "\n",
            "def analyze_output(phase_map, wrapped=True):\n",
            "    \"\"\"\n",
            "    Compute stats for validity, plausibility, and stability.\n",
            "    \"\"\"\n",
            "    stats = {}\n",
            "    \n",
            "    # 1. Numerical Validity\n",
            "    data = phase_map.detach().cpu().numpy() if isinstance(phase_map, torch.Tensor) else phase_map\n",
            "    stats['has_nan'] = np.isnan(data).any()\n",
            "    stats['has_inf'] = np.isinf(data).any()\n",
            "    stats['valid'] = not (stats['has_nan'] or stats['has_inf'])\n",
            "    \n",
            "    # 2. Plausibility\n",
            "    if stats['valid']:\n",
            "        stats['min'] = float(data.min())\n",
            "        stats['max'] = float(data.max())\n",
            "        stats['mean'] = float(data.mean())\n",
            "        stats['std'] = float(data.std())\n",
            "        # Range plausibility: Is it constant?\n",
            "        stats['is_constant'] = stats['std'] < 1e-6\n",
            "    else:\n",
            "        stats['min'] = stats['max'] = stats['mean'] = stats['std'] = np.nan\n",
            "        stats['is_constant'] = True\n",
            "\n",
            "    return stats, data"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# 4. Interactive Widget Panel\n",
            "\n",
            "def update_viz(xc, yc, S, focal_length, wavelength, show_wrapped=True):\n",
            "    # Convert scalars to tensors for the differentiable pipeline (optional here but good for consistency)\n",
            "    t_xc = torch.tensor(float(xc))\n",
            "    t_yc = torch.tensor(float(yc))\n",
            "    t_S = torch.tensor(float(S))\n",
            "    t_f = torch.tensor(float(focal_length))\n",
            "    t_w = torch.tensor(float(wavelength))\n",
            "    \n",
            "    try:\n",
            "        phase = differentiable_forward(t_xc, t_yc, t_S, t_f, t_w, N=256)\n",
            "        \n",
            "        if show_wrapped:\n",
            "            # Wrap phase: angle(exp(1j * phase))\n",
            "            disp_phase = forward_model.wrap_phase(phase)\n",
            "            title_pfx = \"Wrapped\"\n",
            "            cmap = 'twilight'\n",
            "            vmin, vmax = -np.pi, np.pi\n",
            "        else:\n",
            "            disp_phase = phase\n",
            "            title_pfx = \"Unwrapped\"\n",
            "            cmap = 'viridis'\n",
            "            vmin, vmax = None, None\n",
            "\n",
            "        stats, data = analyze_output(disp_phase)\n",
            "        \n",
            "        # Visualization\n",
            "        fig, ax = plt.subplots(1, 2, figsize=(12, 5))\n",
            "        \n",
            "        # Image\n",
            "        im = ax[0].imshow(data, cmap=cmap, vmin=vmin, vmax=vmax, origin='lower')\n",
            "        fig.colorbar(im, ax=ax[0])\n",
            "        ax[0].set_title(f\"{title_pfx} Phase Map\")\n",
            "        ax[0].set_xlabel(\"Pixel X\")\n",
            "        ax[0].set_ylabel(\"Pixel Y\")\n",
            "        \n",
            "        # Histogram\n",
            "        if stats['valid']:\n",
            "            ax[1].hist(data.flatten(), bins=50, color='skyblue', edgecolor='black')\n",
            "            ax[1].set_title(\"Distribution\")\n",
            "            \n",
            "            # Text stats\n",
            "            stat_str = (\n",
            "                f\"Min: {stats['min']:.2f}\\n\"\n",
            "                f\"Max: {stats['max']:.2f}\\n\"\n",
            "                f\"Mean: {stats['mean']:.2f}\\n\"\n",
            "                f\"Std: {stats['std']:.2f}\\n\"\n",
            "                f\"Valid: {stats['valid']}\\n\"\n",
            "                f\"Is Constant: {stats['is_constant']}\"\n",
            "            )\n",
            "            ax[1].text(0.95, 0.95, stat_str, transform=ax[1].transAxes, \n",
            "                       verticalalignment='top', horizontalalignment='right', \n",
            "                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))\n",
            "        else:\n",
            "            ax[1].text(0.5, 0.5, \"INVALID / NaNs Detected\", ha='center', color='red', weight='bold')\n",
            "        \n",
            "        plt.tight_layout()\n",
            "        plt.show()\n",
            "        \n",
            "    except Exception as e:\n",
            "        print(f\"Error in visualization: {e}\")\n",
            "\n",
            "# Widgets\n",
            "style = {'description_width': 'initial'}\n",
            "\n",
            "w_xc = widgets.FloatSlider(value=0.0, min=-1000.0, max=1000.0, step=10, description='Xc (μm)', style=style)\n",
            "w_yc = widgets.FloatSlider(value=0.0, min=-1000.0, max=1000.0, step=10, description='Yc (μm)', style=style)\n",
            "w_S = widgets.FloatSlider(value=20.0, min=1.0, max=100.0, step=1.0, description='Window Size S (μm)', style=style)\n",
            "w_f = widgets.FloatSlider(value=100.0, min=1.0, max=500.0, step=5.0, description='Focal Length (μm)', style=style)\n",
            "w_wl = widgets.FloatSlider(value=0.532, min=0.3, max=1.0, step=0.001, description='Wavelength (μm)', style=style)\n",
            "w_wrap = widgets.Checkbox(value=True, description='Show Wrapped')\n",
            "\n",
            "ui = widgets.VBox([\n",
            "    widgets.HBox([w_xc, w_yc]),\n",
            "    widgets.HBox([w_S, w_f, w_wl]),\n",
            "    w_wrap\n",
            "])\n",
            "\n",
            "out = widgets.interactive_output(update_viz, \n",
            "                                 {'xc': w_xc, 'yc': w_yc, 'S': w_S, \n",
            "                                  'focal_length': w_f, 'wavelength': w_wl, \n",
            "                                  'show_wrapped': w_wrap})\n",
            "\n",
            "display(ui, out)"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# 5. Range Sweep & Instability Detection\n",
            "\n",
            "def sweep_parameter(param_name, range_vals, fixed_params):\n",
            "    \"\"\"\n",
            "    Sweep one parameter while holding others fixed.\n",
            "    \"\"\"\n",
            "    stats_history = []\n",
            "    \n",
            "    print(f\"Sweeping {param_name} over {len(range_vals)} points...\")\n",
            "    \n",
            "    for val in range_vals:\n",
            "        # Update specific param\n",
            "        current_params = fixed_params.copy()\n",
            "        current_params[param_name] = torch.tensor(float(val))\n",
            "        \n",
            "        # To Tensor for others\n",
            "        for k, v in current_params.items():\n",
            "            if not isinstance(v, torch.Tensor):\n",
            "                current_params[k] = torch.tensor(float(v))\n",
            "        \n",
            "        # Run forward\n",
            "        phase = differentiable_forward(\n",
            "            current_params['xc'], \n",
            "            current_params['yc'], \n",
            "            current_params['S'], \n",
            "            current_params['focal_length'], \n",
            "            current_params['wavelength']\n",
            "        )\n",
            "        \n",
            "        # Stats\n",
            "        s, _ = analyze_output(forward_model.wrap_phase(phase))\n",
            "        s['param_value'] = val\n",
            "        stats_history.append(s)\n",
            "        \n",
            "    return stats_history\n",
            "\n",
            "# Define Defaults\n",
            "defaults = {\n",
            "    'xc': 0.0, 'yc': 0.0,\n",
            "    'S': 20.0,\n",
            "    'focal_length': 100.0,\n",
            "    'wavelength': 0.532\n",
            "}\n",
            "\n",
            "# Example Sweep: Focal Length\n",
            "f_range = np.linspace(1.0, 300.0, 50)\n",
            "results = sweep_parameter('focal_length', f_range, defaults)\n",
            "\n",
            "# Plot\n",
            "param_vals = [r['param_value'] for r in results]\n",
            "stds = [r['std'] for r in results]\n",
            "means = [r['mean'] for r in results]\n",
            "\n",
            "fig, ax = plt.subplots(1, 2, figsize=(10, 4))\n",
            "ax[0].plot(param_vals, stds, '-o')\n",
            "ax[0].set_xlabel('Focal Length')\n",
            "ax[0].set_ylabel('Phase Std Dev')\n",
            "ax[0].set_title('Unwrapped Phase Complexity')\n",
            "\n",
            "ax[1].plot(param_vals, means, '-x', color='orange')\n",
            "ax[1].set_xlabel('Focal Length')\n",
            "ax[1].set_ylabel('Phase Mean')\n",
            "ax[1].set_title('Mean Phase Value')\n",
            "\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# 6. 2D Range Map (Xc, Yc)\n",
            "\n",
            "def run_2d_sweep(xc_range, yc_range, steps=20):\n",
            "    res_grid = np.zeros((steps, steps))\n",
            "    \n",
            "    xc_vals = np.linspace(xc_range[0], xc_range[1], steps)\n",
            "    yc_vals = np.linspace(yc_range[0], yc_range[1], steps)\n",
            "    \n",
            "    # Fixed params\n",
            "    S = torch.tensor(20.0)\n",
            "    f = torch.tensor(100.0)\n",
            "    wl = torch.tensor(0.532)\n",
            "    \n",
            "    for i, x in enumerate(xc_vals):\n",
            "        for j, y in enumerate(yc_vals):\n",
            "            try:\n",
            "                # Just check stability score (e.g. std dev of phase)\n",
            "                # or gradient norm (more expensive)\n",
            "                phase = differentiable_forward(torch.tensor(x), torch.tensor(y), S, f, wl)\n",
            "                \n",
            "                # Heuristic: Phase discontinuities (spatial frequency)\n",
            "                # approximated by std dev of gradients of phase map\n",
            "                # Simple proxy: std dev of wrapped phase\n",
            "                wrapped = forward_model.wrap_phase(phase)\n",
            "                score = float(wrapped.std())\n",
            "                \n",
            "                if torch.isnan(phase).any():\n",
            "                    score = -1.0 # Marker for invalid\n",
            "                \n",
            "                res_grid[j, i] = score # Note indices: row->y, col->x\n",
            "                \n",
            "            except Exception as e:\n",
            "                res_grid[j, i] = -1.0\n",
            "                \n",
            "    return xc_vals, yc_vals, res_grid\n",
            "\n",
            "print(\"Running 2D Sweep for Stability Map (may take a moment)...\")\n",
            "xc_vals, yc_vals, grid_score = run_2d_sweep((-2000, 2000), (-2000, 2000), steps=30)\n",
            "\n",
            "plt.figure(figsize=(8, 6))\n",
            "plt.imshow(grid_score, extent=[xc_vals.min(), xc_vals.max(), yc_vals.min(), yc_vals.max()], \n",
            "           origin='lower', aspect='auto', cmap='magma')\n",
            "plt.colorbar(label='Phase Complexity (Std Dev)')\n",
            "plt.title(\"2D Stability Map: Xc vs Yc\")\n",
            "plt.xlabel(\"Xc (μm)\")\n",
            "plt.ylabel(\"Yc (μm)\")\n",
            "plt.show()"
        ]
    },
    {
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# 7. Gradient Sensitivity Diagnostics\n",
            "\n",
            "def check_gradients(xc_val, yc_val):\n",
            "    # Enable gradients\n",
            "    xc = torch.tensor(float(xc_val), requires_grad=True)\n",
            "    yc = torch.tensor(float(yc_val), requires_grad=True)\n",
            "    S = torch.tensor(20.0, requires_grad=True)\n",
            "    f = torch.tensor(100.0, requires_grad=True)\n",
            "    wl = torch.tensor(0.532, requires_grad=True)\n",
            "    \n",
            "    # Forward\n",
            "    phase = differentiable_forward(xc, yc, S, f, wl)\n",
            "    wrapped = forward_model.wrap_phase(phase)\n",
            "    \n",
            "    # Scalar loss: e.g. Mean Energy\n",
            "    # We want to see if changing parameters changes the output\n",
            "    loss = wrapped.mean()\n",
            "    loss.backward()\n",
            "    \n",
            "    grads = {\n",
            "        'xc': xc.grad.item(),\n",
            "        'yc': yc.grad.item(),\n",
            "        'S': S.grad.item(),\n",
            "        'f': f.grad.item(),\n",
            "        'wl': wl.grad.item()\n",
            "    }\n",
            "    return grads\n",
            "\n",
            "print(\"Gradient Sensitivity at (0,0):\")\n",
            "print(check_gradients(0, 0))\n",
            "\n",
            "print(\"\\nGradient Sensitivity at (1000, 1000):\")\n",
            "print(check_gradients(1000, 1000))"
        ]
    },
    {
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "# 8. Recommendations\n",
            "\n",
            "Based on the analysis above:\n",
            "\n",
            "### 1. Permissible Ranges\n",
            "- **Xc, Yc**: [Suggest range based on 2D map, e.g. +/- 1000 microns looks stable]\n",
            "- **Focal Length**: [Min safe value, e.g. > 10 microns]\n",
            "\n",
            "### 2. Caution Zones\n",
            "- Very small focal lengths (< 10um) cause high frequency aliasing in the phase map.\n",
            "- Very large offsets (Xc, Yc > 2000um) might lead to floating point precision drops or reduced sensitivity.\n",
            "\n",
            "### 3. Invalid Configurations\n",
            "- Negative focal lengths or wavelengths.\n",
            "- `S` (Window size) larger than the physical simulation bounds (if any).\n"
        ]
    }
]

notebook_data = {
    "cells": notebook_cells,
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.8.5"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 4
}

with open("stress_test_forward_model.ipynb", "w") as f:
    json.dump(notebook_data, f, indent=2)

print("Notebook generated successfully: stress_test_forward_model.ipynb")
